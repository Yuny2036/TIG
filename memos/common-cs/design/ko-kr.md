# Design
## 좋은 설계 원칙..
*널리 알려진 설계 원칙을 배우고 의식하며 개발하기*

## 응집도<sub>Cohesion</sub>와 결합도<sub>Coupling</sub>
### 응집도
- 모듈이 하나의 목적을 수행하는 **요소들간의 연관성** 척도
- 모듈 내부의 기능적인 응집 정도를 나타냄

### 결합도
- 모듈이 **다른 모듈에 의존하는 정도**의 척도
- 모듈과 모듈간의 상호 결합 정도를 나타냄

## 응집도와 결합도의 높낮음 예시
| |강함|약함|
|---|---|---|
|응집도|로그인, 로그아웃, 비밀번호 변경을 수행하는 UserAuthentication 클래스|문자열 처리, 파일 읽기, 날짜 계산을 수행하는 Util 클래스
|결합도|특정 클래스의 **내부 구현**에 의존하는 UserAuthentication 클래스|**인터페이스**를 통해 사용자 정보를 가져오는 UserAuthentication 클래스

## 좋은 코드를 위해 의식해야 하는 6가지 코드 작성 원칙
1. **D**on't **R**epeat **Y**ourself: 같은 것을 몇 번씩 반복하지 말기
   - 중복 코드는 메서드로
2. **P**rogram **I**ntently and **E**xpressively: 명확하고 표현력 있게 기술하기
   - 애매한 이름 쓰지 말기
   - 누가 봐도 알기 쉬운 이름
   - 컨벤션을 따르기
   - 매직 넘버에 이름 붙이기
     - 예시: `1.1`보다 `tax`가 알기 쉽다`const double tax = 1.1; double result = value * tax;`
3. **S**ingle **R**esponsibility **P**rinciple: 단일 책임 원칙 <sub>클래스에 주어진 책임은 오직 하나</sub>
   - 하나의 클래스, 하나의 일
   - 한 부분의 에러는 한 클래스만 수정하는 것으로 해결되어야 함
     - 이에 부가되는, 클래스 분리에 따른 관리 난이도 상승을 유의할 것
4. **O**pen **C**losed **P**rinciple : 개방 폐쇄 원칙
   - 확장은 자유롭게, 내부 수정은 불가하게
   - 인터페이스를 활용한 적극적인 확장 전략을 고려
5. **S**table **D**ependencies **P**rinciple: 안전한 것에 의존하기
   - ATM 기의 암호 처리와 같이 한번 작성되면 **수정 될 가능성이 없는 것에 의존**
   - 특정 클래스보다 **인터페이스**에 의존
     - 클래스를 직접 사용하지 말고, 클래스를 감싸는 인터페이스를 사용하고, 클래스는 <sub>생성자 등으로</sub> 의존성을 주입받기 
6. **A**cyclic **D**ependencies **P**rinciple: 의존성 비순환 원칙
   - 의존 관계에서 사이클이 발생하지 않게 하기

### 이와 유사한 원칙?
*SOLID 원칙 참고*

## 디자인 패턴


------
------

## Singleton Pattern (Singleton)
소프트웨어 디자인 패턴에서 특정 생성자(Class)의 인스턴스(Instance)가 유일함(Unique)을 보장하는 디자인 패턴, 혹은 바로 그 객체  
```C# (Unity)

public static GameManager instance; // 싱글톤을 할당할 전역 변수
void Awake()
    {
        // 싱글톤 변수 instance가 비어있는가?
        if (instance == null)
        {
            // instance가 비어있다면(null) 그곳에 자기 자신을 할당
            instance = this;
        }
        else
        {
            // instance에 이미 다른 GameManager 오브젝트가 할당되어 있는 경우

            // 씬에 두개 이상의 GameManager 오브젝트가 존재한다는 의미.
            // 싱글톤 오브젝트는 하나만 존재해야 하므로 자신의 게임 오브젝트를 파괴
            Debug.LogWarning("씬에 두개 이상의 게임 매니저가 존재합니다!");
            Destroy(gameObject);
        }
    }
```
\**코드 출처 : 도서 '레트로의 유니티 게임 프로그래밍 에센스' 과정 중 일부*

### Why singleton?
1. **유일함** : 누가 어디에서 접근하더라도 동일한 객체를 가리킬 수 있다.
2. 용이함 : 상기한 *유일함*을 효과적으로 이용하기 위해, 해당 싱글톤을 (언어에 따라) `static` 와 같이 전역 처리해 사용  
   \- 전역 처리한 객체가 서비스 전반적으로 사용하는 데이터를 다루게 하여 하위의 서비스들이 데이터를 쉽게 이용 가능

------
------
